/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package model

import (
	"github.com/apache/plc4x/plc4go/internal/spi/utils"
	"github.com/pkg/errors"
	"io"
)

// Code generated by code-generation. DO NOT EDIT.

// BACnetConstructedDataAnalogInputAll is the data-structure of this message
type BACnetConstructedDataAnalogInputAll struct {
	*BACnetConstructedData
	ObjectIdentifier             *BACnetApplicationTagObjectIdentifier
	ObjectName                   *BACnetApplicationTagCharacterString
	ObjectType                   *BACnetObjectTypeTagged
	PresentValue                 *BACnetApplicationTagReal
	Description                  *BACnetApplicationTagCharacterString
	DeviceType                   *BACnetApplicationTagCharacterString
	StatusFlags                  *BACnetStatusFlagsTagged
	EventState                   *BACnetEventStateTagged
	Reliability                  *BACnetReliabilityTagged
	OutOfService                 *BACnetApplicationTagBoolean
	UpdateInterval               *BACnetApplicationTagUnsignedInteger
	Units                        *BACnetEngineeringUnitsTagged
	MinPresValue                 *BACnetApplicationTagReal
	MaxPresValue                 *BACnetApplicationTagReal
	Resolution                   *BACnetApplicationTagReal
	CovIncrement                 *BACnetApplicationTagReal
	TimeDelay                    *BACnetApplicationTagUnsignedInteger
	NotificationClass            *BACnetApplicationTagUnsignedInteger
	HighLimit                    *BACnetApplicationTagReal
	LowLimit                     *BACnetApplicationTagReal
	Deadband                     *BACnetApplicationTagReal
	LimitEnable                  *BACnetLimitEnableTagged
	EventEnable                  *BACnetEventTransitionBitsTagged
	AckedTransitions             *BACnetEventTransitionBitsTagged
	NotifyType                   *BACnetNotifyTypeTagged
	EventDetectionEnable         *BACnetApplicationTagBoolean
	EventAlgorithmInhibitRef     *BACnetObjectPropertyReference
	EventAlgorithmInhibit        *BACnetApplicationTagBoolean
	TimeDelayNormal              *BACnetApplicationTagUnsignedInteger
	ReliabilityEvaluationInhibit *BACnetApplicationTagBoolean
	InterfaceValue               *BACnetOptionalREAL
	FaultHighLimit               *BACnetApplicationTagReal
	FaultLowLimit                *BACnetApplicationTagReal
	ProfileLocation              *BACnetApplicationTagCharacterString
	ProfileName                  *BACnetApplicationTagCharacterString

	// Arguments.
	TagNumber uint8
}

// IBACnetConstructedDataAnalogInputAll is the corresponding interface of BACnetConstructedDataAnalogInputAll
type IBACnetConstructedDataAnalogInputAll interface {
	IBACnetConstructedData
	// GetObjectIdentifier returns ObjectIdentifier (property field)
	GetObjectIdentifier() *BACnetApplicationTagObjectIdentifier
	// GetObjectName returns ObjectName (property field)
	GetObjectName() *BACnetApplicationTagCharacterString
	// GetObjectType returns ObjectType (property field)
	GetObjectType() *BACnetObjectTypeTagged
	// GetPresentValue returns PresentValue (property field)
	GetPresentValue() *BACnetApplicationTagReal
	// GetDescription returns Description (property field)
	GetDescription() *BACnetApplicationTagCharacterString
	// GetDeviceType returns DeviceType (property field)
	GetDeviceType() *BACnetApplicationTagCharacterString
	// GetStatusFlags returns StatusFlags (property field)
	GetStatusFlags() *BACnetStatusFlagsTagged
	// GetEventState returns EventState (property field)
	GetEventState() *BACnetEventStateTagged
	// GetReliability returns Reliability (property field)
	GetReliability() *BACnetReliabilityTagged
	// GetOutOfService returns OutOfService (property field)
	GetOutOfService() *BACnetApplicationTagBoolean
	// GetUpdateInterval returns UpdateInterval (property field)
	GetUpdateInterval() *BACnetApplicationTagUnsignedInteger
	// GetUnits returns Units (property field)
	GetUnits() *BACnetEngineeringUnitsTagged
	// GetMinPresValue returns MinPresValue (property field)
	GetMinPresValue() *BACnetApplicationTagReal
	// GetMaxPresValue returns MaxPresValue (property field)
	GetMaxPresValue() *BACnetApplicationTagReal
	// GetResolution returns Resolution (property field)
	GetResolution() *BACnetApplicationTagReal
	// GetCovIncrement returns CovIncrement (property field)
	GetCovIncrement() *BACnetApplicationTagReal
	// GetTimeDelay returns TimeDelay (property field)
	GetTimeDelay() *BACnetApplicationTagUnsignedInteger
	// GetNotificationClass returns NotificationClass (property field)
	GetNotificationClass() *BACnetApplicationTagUnsignedInteger
	// GetHighLimit returns HighLimit (property field)
	GetHighLimit() *BACnetApplicationTagReal
	// GetLowLimit returns LowLimit (property field)
	GetLowLimit() *BACnetApplicationTagReal
	// GetDeadband returns Deadband (property field)
	GetDeadband() *BACnetApplicationTagReal
	// GetLimitEnable returns LimitEnable (property field)
	GetLimitEnable() *BACnetLimitEnableTagged
	// GetEventEnable returns EventEnable (property field)
	GetEventEnable() *BACnetEventTransitionBitsTagged
	// GetAckedTransitions returns AckedTransitions (property field)
	GetAckedTransitions() *BACnetEventTransitionBitsTagged
	// GetNotifyType returns NotifyType (property field)
	GetNotifyType() *BACnetNotifyTypeTagged
	// GetEventDetectionEnable returns EventDetectionEnable (property field)
	GetEventDetectionEnable() *BACnetApplicationTagBoolean
	// GetEventAlgorithmInhibitRef returns EventAlgorithmInhibitRef (property field)
	GetEventAlgorithmInhibitRef() *BACnetObjectPropertyReference
	// GetEventAlgorithmInhibit returns EventAlgorithmInhibit (property field)
	GetEventAlgorithmInhibit() *BACnetApplicationTagBoolean
	// GetTimeDelayNormal returns TimeDelayNormal (property field)
	GetTimeDelayNormal() *BACnetApplicationTagUnsignedInteger
	// GetReliabilityEvaluationInhibit returns ReliabilityEvaluationInhibit (property field)
	GetReliabilityEvaluationInhibit() *BACnetApplicationTagBoolean
	// GetInterfaceValue returns InterfaceValue (property field)
	GetInterfaceValue() *BACnetOptionalREAL
	// GetFaultHighLimit returns FaultHighLimit (property field)
	GetFaultHighLimit() *BACnetApplicationTagReal
	// GetFaultLowLimit returns FaultLowLimit (property field)
	GetFaultLowLimit() *BACnetApplicationTagReal
	// GetProfileLocation returns ProfileLocation (property field)
	GetProfileLocation() *BACnetApplicationTagCharacterString
	// GetProfileName returns ProfileName (property field)
	GetProfileName() *BACnetApplicationTagCharacterString
	// GetLengthInBytes returns the length in bytes
	GetLengthInBytes() uint16
	// GetLengthInBits returns the length in bits
	GetLengthInBits() uint16
	// Serialize serializes this type
	Serialize(writeBuffer utils.WriteBuffer) error
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
/////////////////////// Accessors for discriminator values.
///////////////////////

func (m *BACnetConstructedDataAnalogInputAll) GetObjectTypeArgument() BACnetObjectType {
	return BACnetObjectType_ANALOG_INPUT
}

func (m *BACnetConstructedDataAnalogInputAll) GetPropertyIdentifierArgument() BACnetPropertyIdentifier {
	return BACnetPropertyIdentifier_ALL
}

///////////////////////
///////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

func (m *BACnetConstructedDataAnalogInputAll) InitializeParent(parent *BACnetConstructedData, openingTag *BACnetOpeningTag, closingTag *BACnetClosingTag) {
	m.BACnetConstructedData.OpeningTag = openingTag
	m.BACnetConstructedData.ClosingTag = closingTag
}

func (m *BACnetConstructedDataAnalogInputAll) GetParent() *BACnetConstructedData {
	return m.BACnetConstructedData
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
/////////////////////// Accessors for property fields.
///////////////////////

func (m *BACnetConstructedDataAnalogInputAll) GetObjectIdentifier() *BACnetApplicationTagObjectIdentifier {
	return m.ObjectIdentifier
}

func (m *BACnetConstructedDataAnalogInputAll) GetObjectName() *BACnetApplicationTagCharacterString {
	return m.ObjectName
}

func (m *BACnetConstructedDataAnalogInputAll) GetObjectType() *BACnetObjectTypeTagged {
	return m.ObjectType
}

func (m *BACnetConstructedDataAnalogInputAll) GetPresentValue() *BACnetApplicationTagReal {
	return m.PresentValue
}

func (m *BACnetConstructedDataAnalogInputAll) GetDescription() *BACnetApplicationTagCharacterString {
	return m.Description
}

func (m *BACnetConstructedDataAnalogInputAll) GetDeviceType() *BACnetApplicationTagCharacterString {
	return m.DeviceType
}

func (m *BACnetConstructedDataAnalogInputAll) GetStatusFlags() *BACnetStatusFlagsTagged {
	return m.StatusFlags
}

func (m *BACnetConstructedDataAnalogInputAll) GetEventState() *BACnetEventStateTagged {
	return m.EventState
}

func (m *BACnetConstructedDataAnalogInputAll) GetReliability() *BACnetReliabilityTagged {
	return m.Reliability
}

func (m *BACnetConstructedDataAnalogInputAll) GetOutOfService() *BACnetApplicationTagBoolean {
	return m.OutOfService
}

func (m *BACnetConstructedDataAnalogInputAll) GetUpdateInterval() *BACnetApplicationTagUnsignedInteger {
	return m.UpdateInterval
}

func (m *BACnetConstructedDataAnalogInputAll) GetUnits() *BACnetEngineeringUnitsTagged {
	return m.Units
}

func (m *BACnetConstructedDataAnalogInputAll) GetMinPresValue() *BACnetApplicationTagReal {
	return m.MinPresValue
}

func (m *BACnetConstructedDataAnalogInputAll) GetMaxPresValue() *BACnetApplicationTagReal {
	return m.MaxPresValue
}

func (m *BACnetConstructedDataAnalogInputAll) GetResolution() *BACnetApplicationTagReal {
	return m.Resolution
}

func (m *BACnetConstructedDataAnalogInputAll) GetCovIncrement() *BACnetApplicationTagReal {
	return m.CovIncrement
}

func (m *BACnetConstructedDataAnalogInputAll) GetTimeDelay() *BACnetApplicationTagUnsignedInteger {
	return m.TimeDelay
}

func (m *BACnetConstructedDataAnalogInputAll) GetNotificationClass() *BACnetApplicationTagUnsignedInteger {
	return m.NotificationClass
}

func (m *BACnetConstructedDataAnalogInputAll) GetHighLimit() *BACnetApplicationTagReal {
	return m.HighLimit
}

func (m *BACnetConstructedDataAnalogInputAll) GetLowLimit() *BACnetApplicationTagReal {
	return m.LowLimit
}

func (m *BACnetConstructedDataAnalogInputAll) GetDeadband() *BACnetApplicationTagReal {
	return m.Deadband
}

func (m *BACnetConstructedDataAnalogInputAll) GetLimitEnable() *BACnetLimitEnableTagged {
	return m.LimitEnable
}

func (m *BACnetConstructedDataAnalogInputAll) GetEventEnable() *BACnetEventTransitionBitsTagged {
	return m.EventEnable
}

func (m *BACnetConstructedDataAnalogInputAll) GetAckedTransitions() *BACnetEventTransitionBitsTagged {
	return m.AckedTransitions
}

func (m *BACnetConstructedDataAnalogInputAll) GetNotifyType() *BACnetNotifyTypeTagged {
	return m.NotifyType
}

func (m *BACnetConstructedDataAnalogInputAll) GetEventDetectionEnable() *BACnetApplicationTagBoolean {
	return m.EventDetectionEnable
}

func (m *BACnetConstructedDataAnalogInputAll) GetEventAlgorithmInhibitRef() *BACnetObjectPropertyReference {
	return m.EventAlgorithmInhibitRef
}

func (m *BACnetConstructedDataAnalogInputAll) GetEventAlgorithmInhibit() *BACnetApplicationTagBoolean {
	return m.EventAlgorithmInhibit
}

func (m *BACnetConstructedDataAnalogInputAll) GetTimeDelayNormal() *BACnetApplicationTagUnsignedInteger {
	return m.TimeDelayNormal
}

func (m *BACnetConstructedDataAnalogInputAll) GetReliabilityEvaluationInhibit() *BACnetApplicationTagBoolean {
	return m.ReliabilityEvaluationInhibit
}

func (m *BACnetConstructedDataAnalogInputAll) GetInterfaceValue() *BACnetOptionalREAL {
	return m.InterfaceValue
}

func (m *BACnetConstructedDataAnalogInputAll) GetFaultHighLimit() *BACnetApplicationTagReal {
	return m.FaultHighLimit
}

func (m *BACnetConstructedDataAnalogInputAll) GetFaultLowLimit() *BACnetApplicationTagReal {
	return m.FaultLowLimit
}

func (m *BACnetConstructedDataAnalogInputAll) GetProfileLocation() *BACnetApplicationTagCharacterString {
	return m.ProfileLocation
}

func (m *BACnetConstructedDataAnalogInputAll) GetProfileName() *BACnetApplicationTagCharacterString {
	return m.ProfileName
}

///////////////////////
///////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

// NewBACnetConstructedDataAnalogInputAll factory function for BACnetConstructedDataAnalogInputAll
func NewBACnetConstructedDataAnalogInputAll(objectIdentifier *BACnetApplicationTagObjectIdentifier, objectName *BACnetApplicationTagCharacterString, objectType *BACnetObjectTypeTagged, presentValue *BACnetApplicationTagReal, description *BACnetApplicationTagCharacterString, deviceType *BACnetApplicationTagCharacterString, statusFlags *BACnetStatusFlagsTagged, eventState *BACnetEventStateTagged, reliability *BACnetReliabilityTagged, outOfService *BACnetApplicationTagBoolean, updateInterval *BACnetApplicationTagUnsignedInteger, units *BACnetEngineeringUnitsTagged, minPresValue *BACnetApplicationTagReal, maxPresValue *BACnetApplicationTagReal, resolution *BACnetApplicationTagReal, covIncrement *BACnetApplicationTagReal, timeDelay *BACnetApplicationTagUnsignedInteger, notificationClass *BACnetApplicationTagUnsignedInteger, highLimit *BACnetApplicationTagReal, lowLimit *BACnetApplicationTagReal, deadband *BACnetApplicationTagReal, limitEnable *BACnetLimitEnableTagged, eventEnable *BACnetEventTransitionBitsTagged, ackedTransitions *BACnetEventTransitionBitsTagged, notifyType *BACnetNotifyTypeTagged, eventDetectionEnable *BACnetApplicationTagBoolean, eventAlgorithmInhibitRef *BACnetObjectPropertyReference, eventAlgorithmInhibit *BACnetApplicationTagBoolean, timeDelayNormal *BACnetApplicationTagUnsignedInteger, reliabilityEvaluationInhibit *BACnetApplicationTagBoolean, interfaceValue *BACnetOptionalREAL, faultHighLimit *BACnetApplicationTagReal, faultLowLimit *BACnetApplicationTagReal, profileLocation *BACnetApplicationTagCharacterString, profileName *BACnetApplicationTagCharacterString, openingTag *BACnetOpeningTag, closingTag *BACnetClosingTag, tagNumber uint8) *BACnetConstructedDataAnalogInputAll {
	_result := &BACnetConstructedDataAnalogInputAll{
		ObjectIdentifier:             objectIdentifier,
		ObjectName:                   objectName,
		ObjectType:                   objectType,
		PresentValue:                 presentValue,
		Description:                  description,
		DeviceType:                   deviceType,
		StatusFlags:                  statusFlags,
		EventState:                   eventState,
		Reliability:                  reliability,
		OutOfService:                 outOfService,
		UpdateInterval:               updateInterval,
		Units:                        units,
		MinPresValue:                 minPresValue,
		MaxPresValue:                 maxPresValue,
		Resolution:                   resolution,
		CovIncrement:                 covIncrement,
		TimeDelay:                    timeDelay,
		NotificationClass:            notificationClass,
		HighLimit:                    highLimit,
		LowLimit:                     lowLimit,
		Deadband:                     deadband,
		LimitEnable:                  limitEnable,
		EventEnable:                  eventEnable,
		AckedTransitions:             ackedTransitions,
		NotifyType:                   notifyType,
		EventDetectionEnable:         eventDetectionEnable,
		EventAlgorithmInhibitRef:     eventAlgorithmInhibitRef,
		EventAlgorithmInhibit:        eventAlgorithmInhibit,
		TimeDelayNormal:              timeDelayNormal,
		ReliabilityEvaluationInhibit: reliabilityEvaluationInhibit,
		InterfaceValue:               interfaceValue,
		FaultHighLimit:               faultHighLimit,
		FaultLowLimit:                faultLowLimit,
		ProfileLocation:              profileLocation,
		ProfileName:                  profileName,
		BACnetConstructedData:        NewBACnetConstructedData(openingTag, closingTag, tagNumber),
	}
	_result.Child = _result
	return _result
}

func CastBACnetConstructedDataAnalogInputAll(structType interface{}) *BACnetConstructedDataAnalogInputAll {
	if casted, ok := structType.(BACnetConstructedDataAnalogInputAll); ok {
		return &casted
	}
	if casted, ok := structType.(*BACnetConstructedDataAnalogInputAll); ok {
		return casted
	}
	if casted, ok := structType.(BACnetConstructedData); ok {
		return CastBACnetConstructedDataAnalogInputAll(casted.Child)
	}
	if casted, ok := structType.(*BACnetConstructedData); ok {
		return CastBACnetConstructedDataAnalogInputAll(casted.Child)
	}
	return nil
}

func (m *BACnetConstructedDataAnalogInputAll) GetTypeName() string {
	return "BACnetConstructedDataAnalogInputAll"
}

func (m *BACnetConstructedDataAnalogInputAll) GetLengthInBits() uint16 {
	return m.GetLengthInBitsConditional(false)
}

func (m *BACnetConstructedDataAnalogInputAll) GetLengthInBitsConditional(lastItem bool) uint16 {
	lengthInBits := uint16(m.GetParentLengthInBits())

	// Simple field (objectIdentifier)
	lengthInBits += m.ObjectIdentifier.GetLengthInBits()

	// Simple field (objectName)
	lengthInBits += m.ObjectName.GetLengthInBits()

	// Simple field (objectType)
	lengthInBits += m.ObjectType.GetLengthInBits()

	// Simple field (presentValue)
	lengthInBits += m.PresentValue.GetLengthInBits()

	// Optional Field (description)
	if m.Description != nil {
		lengthInBits += (*m.Description).GetLengthInBits()
	}

	// Optional Field (deviceType)
	if m.DeviceType != nil {
		lengthInBits += (*m.DeviceType).GetLengthInBits()
	}

	// Simple field (statusFlags)
	lengthInBits += m.StatusFlags.GetLengthInBits()

	// Simple field (eventState)
	lengthInBits += m.EventState.GetLengthInBits()

	// Optional Field (reliability)
	if m.Reliability != nil {
		lengthInBits += (*m.Reliability).GetLengthInBits()
	}

	// Simple field (outOfService)
	lengthInBits += m.OutOfService.GetLengthInBits()

	// Optional Field (updateInterval)
	if m.UpdateInterval != nil {
		lengthInBits += (*m.UpdateInterval).GetLengthInBits()
	}

	// Simple field (units)
	lengthInBits += m.Units.GetLengthInBits()

	// Optional Field (minPresValue)
	if m.MinPresValue != nil {
		lengthInBits += (*m.MinPresValue).GetLengthInBits()
	}

	// Optional Field (maxPresValue)
	if m.MaxPresValue != nil {
		lengthInBits += (*m.MaxPresValue).GetLengthInBits()
	}

	// Optional Field (resolution)
	if m.Resolution != nil {
		lengthInBits += (*m.Resolution).GetLengthInBits()
	}

	// Optional Field (covIncrement)
	if m.CovIncrement != nil {
		lengthInBits += (*m.CovIncrement).GetLengthInBits()
	}

	// Optional Field (timeDelay)
	if m.TimeDelay != nil {
		lengthInBits += (*m.TimeDelay).GetLengthInBits()
	}

	// Optional Field (notificationClass)
	if m.NotificationClass != nil {
		lengthInBits += (*m.NotificationClass).GetLengthInBits()
	}

	// Optional Field (highLimit)
	if m.HighLimit != nil {
		lengthInBits += (*m.HighLimit).GetLengthInBits()
	}

	// Optional Field (lowLimit)
	if m.LowLimit != nil {
		lengthInBits += (*m.LowLimit).GetLengthInBits()
	}

	// Optional Field (deadband)
	if m.Deadband != nil {
		lengthInBits += (*m.Deadband).GetLengthInBits()
	}

	// Optional Field (limitEnable)
	if m.LimitEnable != nil {
		lengthInBits += (*m.LimitEnable).GetLengthInBits()
	}

	// Optional Field (eventEnable)
	if m.EventEnable != nil {
		lengthInBits += (*m.EventEnable).GetLengthInBits()
	}

	// Optional Field (ackedTransitions)
	if m.AckedTransitions != nil {
		lengthInBits += (*m.AckedTransitions).GetLengthInBits()
	}

	// Optional Field (notifyType)
	if m.NotifyType != nil {
		lengthInBits += (*m.NotifyType).GetLengthInBits()
	}

	// Optional Field (eventDetectionEnable)
	if m.EventDetectionEnable != nil {
		lengthInBits += (*m.EventDetectionEnable).GetLengthInBits()
	}

	// Optional Field (eventAlgorithmInhibitRef)
	if m.EventAlgorithmInhibitRef != nil {
		lengthInBits += (*m.EventAlgorithmInhibitRef).GetLengthInBits()
	}

	// Optional Field (eventAlgorithmInhibit)
	if m.EventAlgorithmInhibit != nil {
		lengthInBits += (*m.EventAlgorithmInhibit).GetLengthInBits()
	}

	// Optional Field (timeDelayNormal)
	if m.TimeDelayNormal != nil {
		lengthInBits += (*m.TimeDelayNormal).GetLengthInBits()
	}

	// Optional Field (reliabilityEvaluationInhibit)
	if m.ReliabilityEvaluationInhibit != nil {
		lengthInBits += (*m.ReliabilityEvaluationInhibit).GetLengthInBits()
	}

	// Optional Field (interfaceValue)
	if m.InterfaceValue != nil {
		lengthInBits += (*m.InterfaceValue).GetLengthInBits()
	}

	// Optional Field (faultHighLimit)
	if m.FaultHighLimit != nil {
		lengthInBits += (*m.FaultHighLimit).GetLengthInBits()
	}

	// Optional Field (faultLowLimit)
	if m.FaultLowLimit != nil {
		lengthInBits += (*m.FaultLowLimit).GetLengthInBits()
	}

	// Optional Field (profileLocation)
	if m.ProfileLocation != nil {
		lengthInBits += (*m.ProfileLocation).GetLengthInBits()
	}

	// Optional Field (profileName)
	if m.ProfileName != nil {
		lengthInBits += (*m.ProfileName).GetLengthInBits()
	}

	return lengthInBits
}

func (m *BACnetConstructedDataAnalogInputAll) GetLengthInBytes() uint16 {
	return m.GetLengthInBits() / 8
}

func BACnetConstructedDataAnalogInputAllParse(readBuffer utils.ReadBuffer, tagNumber uint8, objectTypeArgument BACnetObjectType, propertyIdentifierArgument BACnetPropertyIdentifier) (*BACnetConstructedDataAnalogInputAll, error) {
	positionAware := readBuffer
	_ = positionAware
	if pullErr := readBuffer.PullContext("BACnetConstructedDataAnalogInputAll"); pullErr != nil {
		return nil, pullErr
	}
	currentPos := positionAware.GetPos()
	_ = currentPos

	// Simple Field (objectIdentifier)
	if pullErr := readBuffer.PullContext("objectIdentifier"); pullErr != nil {
		return nil, pullErr
	}
	_objectIdentifier, _objectIdentifierErr := BACnetApplicationTagParse(readBuffer)
	if _objectIdentifierErr != nil {
		return nil, errors.Wrap(_objectIdentifierErr, "Error parsing 'objectIdentifier' field")
	}
	objectIdentifier := CastBACnetApplicationTagObjectIdentifier(_objectIdentifier)
	if closeErr := readBuffer.CloseContext("objectIdentifier"); closeErr != nil {
		return nil, closeErr
	}

	// Simple Field (objectName)
	if pullErr := readBuffer.PullContext("objectName"); pullErr != nil {
		return nil, pullErr
	}
	_objectName, _objectNameErr := BACnetApplicationTagParse(readBuffer)
	if _objectNameErr != nil {
		return nil, errors.Wrap(_objectNameErr, "Error parsing 'objectName' field")
	}
	objectName := CastBACnetApplicationTagCharacterString(_objectName)
	if closeErr := readBuffer.CloseContext("objectName"); closeErr != nil {
		return nil, closeErr
	}

	// Simple Field (objectType)
	if pullErr := readBuffer.PullContext("objectType"); pullErr != nil {
		return nil, pullErr
	}
	_objectType, _objectTypeErr := BACnetObjectTypeTaggedParse(readBuffer, uint8(uint8(0)), TagClass(TagClass_APPLICATION_TAGS))
	if _objectTypeErr != nil {
		return nil, errors.Wrap(_objectTypeErr, "Error parsing 'objectType' field")
	}
	objectType := CastBACnetObjectTypeTagged(_objectType)
	if closeErr := readBuffer.CloseContext("objectType"); closeErr != nil {
		return nil, closeErr
	}

	// Simple Field (presentValue)
	if pullErr := readBuffer.PullContext("presentValue"); pullErr != nil {
		return nil, pullErr
	}
	_presentValue, _presentValueErr := BACnetApplicationTagParse(readBuffer)
	if _presentValueErr != nil {
		return nil, errors.Wrap(_presentValueErr, "Error parsing 'presentValue' field")
	}
	presentValue := CastBACnetApplicationTagReal(_presentValue)
	if closeErr := readBuffer.CloseContext("presentValue"); closeErr != nil {
		return nil, closeErr
	}

	// Optional Field (description) (Can be skipped, if a given expression evaluates to false)
	var description *BACnetApplicationTagCharacterString = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("description"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'description' field")
		default:
			description = CastBACnetApplicationTagCharacterString(_val)
			if closeErr := readBuffer.CloseContext("description"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (deviceType) (Can be skipped, if a given expression evaluates to false)
	var deviceType *BACnetApplicationTagCharacterString = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("deviceType"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'deviceType' field")
		default:
			deviceType = CastBACnetApplicationTagCharacterString(_val)
			if closeErr := readBuffer.CloseContext("deviceType"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Simple Field (statusFlags)
	if pullErr := readBuffer.PullContext("statusFlags"); pullErr != nil {
		return nil, pullErr
	}
	_statusFlags, _statusFlagsErr := BACnetStatusFlagsTaggedParse(readBuffer, uint8(uint8(0)), TagClass(TagClass_APPLICATION_TAGS))
	if _statusFlagsErr != nil {
		return nil, errors.Wrap(_statusFlagsErr, "Error parsing 'statusFlags' field")
	}
	statusFlags := CastBACnetStatusFlagsTagged(_statusFlags)
	if closeErr := readBuffer.CloseContext("statusFlags"); closeErr != nil {
		return nil, closeErr
	}

	// Simple Field (eventState)
	if pullErr := readBuffer.PullContext("eventState"); pullErr != nil {
		return nil, pullErr
	}
	_eventState, _eventStateErr := BACnetEventStateTaggedParse(readBuffer, uint8(uint8(0)), TagClass(TagClass_APPLICATION_TAGS))
	if _eventStateErr != nil {
		return nil, errors.Wrap(_eventStateErr, "Error parsing 'eventState' field")
	}
	eventState := CastBACnetEventStateTagged(_eventState)
	if closeErr := readBuffer.CloseContext("eventState"); closeErr != nil {
		return nil, closeErr
	}

	// Optional Field (reliability) (Can be skipped, if a given expression evaluates to false)
	var reliability *BACnetReliabilityTagged = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("reliability"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetReliabilityTaggedParse(readBuffer, uint8(0), TagClass_APPLICATION_TAGS)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'reliability' field")
		default:
			reliability = CastBACnetReliabilityTagged(_val)
			if closeErr := readBuffer.CloseContext("reliability"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Simple Field (outOfService)
	if pullErr := readBuffer.PullContext("outOfService"); pullErr != nil {
		return nil, pullErr
	}
	_outOfService, _outOfServiceErr := BACnetApplicationTagParse(readBuffer)
	if _outOfServiceErr != nil {
		return nil, errors.Wrap(_outOfServiceErr, "Error parsing 'outOfService' field")
	}
	outOfService := CastBACnetApplicationTagBoolean(_outOfService)
	if closeErr := readBuffer.CloseContext("outOfService"); closeErr != nil {
		return nil, closeErr
	}

	// Optional Field (updateInterval) (Can be skipped, if a given expression evaluates to false)
	var updateInterval *BACnetApplicationTagUnsignedInteger = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("updateInterval"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'updateInterval' field")
		default:
			updateInterval = CastBACnetApplicationTagUnsignedInteger(_val)
			if closeErr := readBuffer.CloseContext("updateInterval"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Simple Field (units)
	if pullErr := readBuffer.PullContext("units"); pullErr != nil {
		return nil, pullErr
	}
	_units, _unitsErr := BACnetEngineeringUnitsTaggedParse(readBuffer, uint8(uint8(0)), TagClass(TagClass_APPLICATION_TAGS))
	if _unitsErr != nil {
		return nil, errors.Wrap(_unitsErr, "Error parsing 'units' field")
	}
	units := CastBACnetEngineeringUnitsTagged(_units)
	if closeErr := readBuffer.CloseContext("units"); closeErr != nil {
		return nil, closeErr
	}

	// Optional Field (minPresValue) (Can be skipped, if a given expression evaluates to false)
	var minPresValue *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("minPresValue"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'minPresValue' field")
		default:
			minPresValue = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("minPresValue"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (maxPresValue) (Can be skipped, if a given expression evaluates to false)
	var maxPresValue *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("maxPresValue"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'maxPresValue' field")
		default:
			maxPresValue = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("maxPresValue"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (resolution) (Can be skipped, if a given expression evaluates to false)
	var resolution *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("resolution"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'resolution' field")
		default:
			resolution = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("resolution"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (covIncrement) (Can be skipped, if a given expression evaluates to false)
	var covIncrement *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("covIncrement"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'covIncrement' field")
		default:
			covIncrement = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("covIncrement"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (timeDelay) (Can be skipped, if a given expression evaluates to false)
	var timeDelay *BACnetApplicationTagUnsignedInteger = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("timeDelay"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'timeDelay' field")
		default:
			timeDelay = CastBACnetApplicationTagUnsignedInteger(_val)
			if closeErr := readBuffer.CloseContext("timeDelay"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (notificationClass) (Can be skipped, if a given expression evaluates to false)
	var notificationClass *BACnetApplicationTagUnsignedInteger = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("notificationClass"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'notificationClass' field")
		default:
			notificationClass = CastBACnetApplicationTagUnsignedInteger(_val)
			if closeErr := readBuffer.CloseContext("notificationClass"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (highLimit) (Can be skipped, if a given expression evaluates to false)
	var highLimit *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("highLimit"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'highLimit' field")
		default:
			highLimit = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("highLimit"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (lowLimit) (Can be skipped, if a given expression evaluates to false)
	var lowLimit *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("lowLimit"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'lowLimit' field")
		default:
			lowLimit = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("lowLimit"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (deadband) (Can be skipped, if a given expression evaluates to false)
	var deadband *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("deadband"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'deadband' field")
		default:
			deadband = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("deadband"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (limitEnable) (Can be skipped, if a given expression evaluates to false)
	var limitEnable *BACnetLimitEnableTagged = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("limitEnable"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetLimitEnableTaggedParse(readBuffer, uint8(0), TagClass_APPLICATION_TAGS)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'limitEnable' field")
		default:
			limitEnable = CastBACnetLimitEnableTagged(_val)
			if closeErr := readBuffer.CloseContext("limitEnable"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (eventEnable) (Can be skipped, if a given expression evaluates to false)
	var eventEnable *BACnetEventTransitionBitsTagged = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("eventEnable"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetEventTransitionBitsTaggedParse(readBuffer, uint8(0), TagClass_APPLICATION_TAGS)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'eventEnable' field")
		default:
			eventEnable = CastBACnetEventTransitionBitsTagged(_val)
			if closeErr := readBuffer.CloseContext("eventEnable"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (ackedTransitions) (Can be skipped, if a given expression evaluates to false)
	var ackedTransitions *BACnetEventTransitionBitsTagged = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("ackedTransitions"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetEventTransitionBitsTaggedParse(readBuffer, uint8(0), TagClass_APPLICATION_TAGS)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'ackedTransitions' field")
		default:
			ackedTransitions = CastBACnetEventTransitionBitsTagged(_val)
			if closeErr := readBuffer.CloseContext("ackedTransitions"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (notifyType) (Can be skipped, if a given expression evaluates to false)
	var notifyType *BACnetNotifyTypeTagged = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("notifyType"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetNotifyTypeTaggedParse(readBuffer, uint8(0), TagClass_APPLICATION_TAGS)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'notifyType' field")
		default:
			notifyType = CastBACnetNotifyTypeTagged(_val)
			if closeErr := readBuffer.CloseContext("notifyType"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (eventDetectionEnable) (Can be skipped, if a given expression evaluates to false)
	var eventDetectionEnable *BACnetApplicationTagBoolean = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("eventDetectionEnable"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'eventDetectionEnable' field")
		default:
			eventDetectionEnable = CastBACnetApplicationTagBoolean(_val)
			if closeErr := readBuffer.CloseContext("eventDetectionEnable"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (eventAlgorithmInhibitRef) (Can be skipped, if a given expression evaluates to false)
	var eventAlgorithmInhibitRef *BACnetObjectPropertyReference = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("eventAlgorithmInhibitRef"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetObjectPropertyReferenceParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'eventAlgorithmInhibitRef' field")
		default:
			eventAlgorithmInhibitRef = CastBACnetObjectPropertyReference(_val)
			if closeErr := readBuffer.CloseContext("eventAlgorithmInhibitRef"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (eventAlgorithmInhibit) (Can be skipped, if a given expression evaluates to false)
	var eventAlgorithmInhibit *BACnetApplicationTagBoolean = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("eventAlgorithmInhibit"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'eventAlgorithmInhibit' field")
		default:
			eventAlgorithmInhibit = CastBACnetApplicationTagBoolean(_val)
			if closeErr := readBuffer.CloseContext("eventAlgorithmInhibit"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (timeDelayNormal) (Can be skipped, if a given expression evaluates to false)
	var timeDelayNormal *BACnetApplicationTagUnsignedInteger = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("timeDelayNormal"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'timeDelayNormal' field")
		default:
			timeDelayNormal = CastBACnetApplicationTagUnsignedInteger(_val)
			if closeErr := readBuffer.CloseContext("timeDelayNormal"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (reliabilityEvaluationInhibit) (Can be skipped, if a given expression evaluates to false)
	var reliabilityEvaluationInhibit *BACnetApplicationTagBoolean = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("reliabilityEvaluationInhibit"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'reliabilityEvaluationInhibit' field")
		default:
			reliabilityEvaluationInhibit = CastBACnetApplicationTagBoolean(_val)
			if closeErr := readBuffer.CloseContext("reliabilityEvaluationInhibit"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (interfaceValue) (Can be skipped, if a given expression evaluates to false)
	var interfaceValue *BACnetOptionalREAL = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("interfaceValue"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetOptionalREALParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'interfaceValue' field")
		default:
			interfaceValue = CastBACnetOptionalREAL(_val)
			if closeErr := readBuffer.CloseContext("interfaceValue"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (faultHighLimit) (Can be skipped, if a given expression evaluates to false)
	var faultHighLimit *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("faultHighLimit"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'faultHighLimit' field")
		default:
			faultHighLimit = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("faultHighLimit"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (faultLowLimit) (Can be skipped, if a given expression evaluates to false)
	var faultLowLimit *BACnetApplicationTagReal = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("faultLowLimit"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'faultLowLimit' field")
		default:
			faultLowLimit = CastBACnetApplicationTagReal(_val)
			if closeErr := readBuffer.CloseContext("faultLowLimit"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (profileLocation) (Can be skipped, if a given expression evaluates to false)
	var profileLocation *BACnetApplicationTagCharacterString = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("profileLocation"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'profileLocation' field")
		default:
			profileLocation = CastBACnetApplicationTagCharacterString(_val)
			if closeErr := readBuffer.CloseContext("profileLocation"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (profileName) (Can be skipped, if a given expression evaluates to false)
	var profileName *BACnetApplicationTagCharacterString = nil
	{
		currentPos = positionAware.GetPos()
		if pullErr := readBuffer.PullContext("profileName"); pullErr != nil {
			return nil, pullErr
		}
		_val, _err := BACnetApplicationTagParse(readBuffer)
		switch {
		case errors.Is(_err, utils.ParseAssertError{}) || errors.Is(_err, io.EOF):
			readBuffer.Reset(currentPos)
		case _err != nil:
			return nil, errors.Wrap(_err, "Error parsing 'profileName' field")
		default:
			profileName = CastBACnetApplicationTagCharacterString(_val)
			if closeErr := readBuffer.CloseContext("profileName"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	if closeErr := readBuffer.CloseContext("BACnetConstructedDataAnalogInputAll"); closeErr != nil {
		return nil, closeErr
	}

	// Create a partially initialized instance
	_child := &BACnetConstructedDataAnalogInputAll{
		ObjectIdentifier:             CastBACnetApplicationTagObjectIdentifier(objectIdentifier),
		ObjectName:                   CastBACnetApplicationTagCharacterString(objectName),
		ObjectType:                   CastBACnetObjectTypeTagged(objectType),
		PresentValue:                 CastBACnetApplicationTagReal(presentValue),
		Description:                  CastBACnetApplicationTagCharacterString(description),
		DeviceType:                   CastBACnetApplicationTagCharacterString(deviceType),
		StatusFlags:                  CastBACnetStatusFlagsTagged(statusFlags),
		EventState:                   CastBACnetEventStateTagged(eventState),
		Reliability:                  CastBACnetReliabilityTagged(reliability),
		OutOfService:                 CastBACnetApplicationTagBoolean(outOfService),
		UpdateInterval:               CastBACnetApplicationTagUnsignedInteger(updateInterval),
		Units:                        CastBACnetEngineeringUnitsTagged(units),
		MinPresValue:                 CastBACnetApplicationTagReal(minPresValue),
		MaxPresValue:                 CastBACnetApplicationTagReal(maxPresValue),
		Resolution:                   CastBACnetApplicationTagReal(resolution),
		CovIncrement:                 CastBACnetApplicationTagReal(covIncrement),
		TimeDelay:                    CastBACnetApplicationTagUnsignedInteger(timeDelay),
		NotificationClass:            CastBACnetApplicationTagUnsignedInteger(notificationClass),
		HighLimit:                    CastBACnetApplicationTagReal(highLimit),
		LowLimit:                     CastBACnetApplicationTagReal(lowLimit),
		Deadband:                     CastBACnetApplicationTagReal(deadband),
		LimitEnable:                  CastBACnetLimitEnableTagged(limitEnable),
		EventEnable:                  CastBACnetEventTransitionBitsTagged(eventEnable),
		AckedTransitions:             CastBACnetEventTransitionBitsTagged(ackedTransitions),
		NotifyType:                   CastBACnetNotifyTypeTagged(notifyType),
		EventDetectionEnable:         CastBACnetApplicationTagBoolean(eventDetectionEnable),
		EventAlgorithmInhibitRef:     CastBACnetObjectPropertyReference(eventAlgorithmInhibitRef),
		EventAlgorithmInhibit:        CastBACnetApplicationTagBoolean(eventAlgorithmInhibit),
		TimeDelayNormal:              CastBACnetApplicationTagUnsignedInteger(timeDelayNormal),
		ReliabilityEvaluationInhibit: CastBACnetApplicationTagBoolean(reliabilityEvaluationInhibit),
		InterfaceValue:               CastBACnetOptionalREAL(interfaceValue),
		FaultHighLimit:               CastBACnetApplicationTagReal(faultHighLimit),
		FaultLowLimit:                CastBACnetApplicationTagReal(faultLowLimit),
		ProfileLocation:              CastBACnetApplicationTagCharacterString(profileLocation),
		ProfileName:                  CastBACnetApplicationTagCharacterString(profileName),
		BACnetConstructedData:        &BACnetConstructedData{},
	}
	_child.BACnetConstructedData.Child = _child
	return _child, nil
}

func (m *BACnetConstructedDataAnalogInputAll) Serialize(writeBuffer utils.WriteBuffer) error {
	positionAware := writeBuffer
	_ = positionAware
	ser := func() error {
		if pushErr := writeBuffer.PushContext("BACnetConstructedDataAnalogInputAll"); pushErr != nil {
			return pushErr
		}

		// Simple Field (objectIdentifier)
		if pushErr := writeBuffer.PushContext("objectIdentifier"); pushErr != nil {
			return pushErr
		}
		_objectIdentifierErr := m.ObjectIdentifier.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("objectIdentifier"); popErr != nil {
			return popErr
		}
		if _objectIdentifierErr != nil {
			return errors.Wrap(_objectIdentifierErr, "Error serializing 'objectIdentifier' field")
		}

		// Simple Field (objectName)
		if pushErr := writeBuffer.PushContext("objectName"); pushErr != nil {
			return pushErr
		}
		_objectNameErr := m.ObjectName.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("objectName"); popErr != nil {
			return popErr
		}
		if _objectNameErr != nil {
			return errors.Wrap(_objectNameErr, "Error serializing 'objectName' field")
		}

		// Simple Field (objectType)
		if pushErr := writeBuffer.PushContext("objectType"); pushErr != nil {
			return pushErr
		}
		_objectTypeErr := m.ObjectType.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("objectType"); popErr != nil {
			return popErr
		}
		if _objectTypeErr != nil {
			return errors.Wrap(_objectTypeErr, "Error serializing 'objectType' field")
		}

		// Simple Field (presentValue)
		if pushErr := writeBuffer.PushContext("presentValue"); pushErr != nil {
			return pushErr
		}
		_presentValueErr := m.PresentValue.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("presentValue"); popErr != nil {
			return popErr
		}
		if _presentValueErr != nil {
			return errors.Wrap(_presentValueErr, "Error serializing 'presentValue' field")
		}

		// Optional Field (description) (Can be skipped, if the value is null)
		var description *BACnetApplicationTagCharacterString = nil
		if m.Description != nil {
			if pushErr := writeBuffer.PushContext("description"); pushErr != nil {
				return pushErr
			}
			description = m.Description
			_descriptionErr := description.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("description"); popErr != nil {
				return popErr
			}
			if _descriptionErr != nil {
				return errors.Wrap(_descriptionErr, "Error serializing 'description' field")
			}
		}

		// Optional Field (deviceType) (Can be skipped, if the value is null)
		var deviceType *BACnetApplicationTagCharacterString = nil
		if m.DeviceType != nil {
			if pushErr := writeBuffer.PushContext("deviceType"); pushErr != nil {
				return pushErr
			}
			deviceType = m.DeviceType
			_deviceTypeErr := deviceType.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("deviceType"); popErr != nil {
				return popErr
			}
			if _deviceTypeErr != nil {
				return errors.Wrap(_deviceTypeErr, "Error serializing 'deviceType' field")
			}
		}

		// Simple Field (statusFlags)
		if pushErr := writeBuffer.PushContext("statusFlags"); pushErr != nil {
			return pushErr
		}
		_statusFlagsErr := m.StatusFlags.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("statusFlags"); popErr != nil {
			return popErr
		}
		if _statusFlagsErr != nil {
			return errors.Wrap(_statusFlagsErr, "Error serializing 'statusFlags' field")
		}

		// Simple Field (eventState)
		if pushErr := writeBuffer.PushContext("eventState"); pushErr != nil {
			return pushErr
		}
		_eventStateErr := m.EventState.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("eventState"); popErr != nil {
			return popErr
		}
		if _eventStateErr != nil {
			return errors.Wrap(_eventStateErr, "Error serializing 'eventState' field")
		}

		// Optional Field (reliability) (Can be skipped, if the value is null)
		var reliability *BACnetReliabilityTagged = nil
		if m.Reliability != nil {
			if pushErr := writeBuffer.PushContext("reliability"); pushErr != nil {
				return pushErr
			}
			reliability = m.Reliability
			_reliabilityErr := reliability.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("reliability"); popErr != nil {
				return popErr
			}
			if _reliabilityErr != nil {
				return errors.Wrap(_reliabilityErr, "Error serializing 'reliability' field")
			}
		}

		// Simple Field (outOfService)
		if pushErr := writeBuffer.PushContext("outOfService"); pushErr != nil {
			return pushErr
		}
		_outOfServiceErr := m.OutOfService.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("outOfService"); popErr != nil {
			return popErr
		}
		if _outOfServiceErr != nil {
			return errors.Wrap(_outOfServiceErr, "Error serializing 'outOfService' field")
		}

		// Optional Field (updateInterval) (Can be skipped, if the value is null)
		var updateInterval *BACnetApplicationTagUnsignedInteger = nil
		if m.UpdateInterval != nil {
			if pushErr := writeBuffer.PushContext("updateInterval"); pushErr != nil {
				return pushErr
			}
			updateInterval = m.UpdateInterval
			_updateIntervalErr := updateInterval.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("updateInterval"); popErr != nil {
				return popErr
			}
			if _updateIntervalErr != nil {
				return errors.Wrap(_updateIntervalErr, "Error serializing 'updateInterval' field")
			}
		}

		// Simple Field (units)
		if pushErr := writeBuffer.PushContext("units"); pushErr != nil {
			return pushErr
		}
		_unitsErr := m.Units.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("units"); popErr != nil {
			return popErr
		}
		if _unitsErr != nil {
			return errors.Wrap(_unitsErr, "Error serializing 'units' field")
		}

		// Optional Field (minPresValue) (Can be skipped, if the value is null)
		var minPresValue *BACnetApplicationTagReal = nil
		if m.MinPresValue != nil {
			if pushErr := writeBuffer.PushContext("minPresValue"); pushErr != nil {
				return pushErr
			}
			minPresValue = m.MinPresValue
			_minPresValueErr := minPresValue.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("minPresValue"); popErr != nil {
				return popErr
			}
			if _minPresValueErr != nil {
				return errors.Wrap(_minPresValueErr, "Error serializing 'minPresValue' field")
			}
		}

		// Optional Field (maxPresValue) (Can be skipped, if the value is null)
		var maxPresValue *BACnetApplicationTagReal = nil
		if m.MaxPresValue != nil {
			if pushErr := writeBuffer.PushContext("maxPresValue"); pushErr != nil {
				return pushErr
			}
			maxPresValue = m.MaxPresValue
			_maxPresValueErr := maxPresValue.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("maxPresValue"); popErr != nil {
				return popErr
			}
			if _maxPresValueErr != nil {
				return errors.Wrap(_maxPresValueErr, "Error serializing 'maxPresValue' field")
			}
		}

		// Optional Field (resolution) (Can be skipped, if the value is null)
		var resolution *BACnetApplicationTagReal = nil
		if m.Resolution != nil {
			if pushErr := writeBuffer.PushContext("resolution"); pushErr != nil {
				return pushErr
			}
			resolution = m.Resolution
			_resolutionErr := resolution.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("resolution"); popErr != nil {
				return popErr
			}
			if _resolutionErr != nil {
				return errors.Wrap(_resolutionErr, "Error serializing 'resolution' field")
			}
		}

		// Optional Field (covIncrement) (Can be skipped, if the value is null)
		var covIncrement *BACnetApplicationTagReal = nil
		if m.CovIncrement != nil {
			if pushErr := writeBuffer.PushContext("covIncrement"); pushErr != nil {
				return pushErr
			}
			covIncrement = m.CovIncrement
			_covIncrementErr := covIncrement.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("covIncrement"); popErr != nil {
				return popErr
			}
			if _covIncrementErr != nil {
				return errors.Wrap(_covIncrementErr, "Error serializing 'covIncrement' field")
			}
		}

		// Optional Field (timeDelay) (Can be skipped, if the value is null)
		var timeDelay *BACnetApplicationTagUnsignedInteger = nil
		if m.TimeDelay != nil {
			if pushErr := writeBuffer.PushContext("timeDelay"); pushErr != nil {
				return pushErr
			}
			timeDelay = m.TimeDelay
			_timeDelayErr := timeDelay.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("timeDelay"); popErr != nil {
				return popErr
			}
			if _timeDelayErr != nil {
				return errors.Wrap(_timeDelayErr, "Error serializing 'timeDelay' field")
			}
		}

		// Optional Field (notificationClass) (Can be skipped, if the value is null)
		var notificationClass *BACnetApplicationTagUnsignedInteger = nil
		if m.NotificationClass != nil {
			if pushErr := writeBuffer.PushContext("notificationClass"); pushErr != nil {
				return pushErr
			}
			notificationClass = m.NotificationClass
			_notificationClassErr := notificationClass.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("notificationClass"); popErr != nil {
				return popErr
			}
			if _notificationClassErr != nil {
				return errors.Wrap(_notificationClassErr, "Error serializing 'notificationClass' field")
			}
		}

		// Optional Field (highLimit) (Can be skipped, if the value is null)
		var highLimit *BACnetApplicationTagReal = nil
		if m.HighLimit != nil {
			if pushErr := writeBuffer.PushContext("highLimit"); pushErr != nil {
				return pushErr
			}
			highLimit = m.HighLimit
			_highLimitErr := highLimit.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("highLimit"); popErr != nil {
				return popErr
			}
			if _highLimitErr != nil {
				return errors.Wrap(_highLimitErr, "Error serializing 'highLimit' field")
			}
		}

		// Optional Field (lowLimit) (Can be skipped, if the value is null)
		var lowLimit *BACnetApplicationTagReal = nil
		if m.LowLimit != nil {
			if pushErr := writeBuffer.PushContext("lowLimit"); pushErr != nil {
				return pushErr
			}
			lowLimit = m.LowLimit
			_lowLimitErr := lowLimit.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("lowLimit"); popErr != nil {
				return popErr
			}
			if _lowLimitErr != nil {
				return errors.Wrap(_lowLimitErr, "Error serializing 'lowLimit' field")
			}
		}

		// Optional Field (deadband) (Can be skipped, if the value is null)
		var deadband *BACnetApplicationTagReal = nil
		if m.Deadband != nil {
			if pushErr := writeBuffer.PushContext("deadband"); pushErr != nil {
				return pushErr
			}
			deadband = m.Deadband
			_deadbandErr := deadband.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("deadband"); popErr != nil {
				return popErr
			}
			if _deadbandErr != nil {
				return errors.Wrap(_deadbandErr, "Error serializing 'deadband' field")
			}
		}

		// Optional Field (limitEnable) (Can be skipped, if the value is null)
		var limitEnable *BACnetLimitEnableTagged = nil
		if m.LimitEnable != nil {
			if pushErr := writeBuffer.PushContext("limitEnable"); pushErr != nil {
				return pushErr
			}
			limitEnable = m.LimitEnable
			_limitEnableErr := limitEnable.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("limitEnable"); popErr != nil {
				return popErr
			}
			if _limitEnableErr != nil {
				return errors.Wrap(_limitEnableErr, "Error serializing 'limitEnable' field")
			}
		}

		// Optional Field (eventEnable) (Can be skipped, if the value is null)
		var eventEnable *BACnetEventTransitionBitsTagged = nil
		if m.EventEnable != nil {
			if pushErr := writeBuffer.PushContext("eventEnable"); pushErr != nil {
				return pushErr
			}
			eventEnable = m.EventEnable
			_eventEnableErr := eventEnable.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("eventEnable"); popErr != nil {
				return popErr
			}
			if _eventEnableErr != nil {
				return errors.Wrap(_eventEnableErr, "Error serializing 'eventEnable' field")
			}
		}

		// Optional Field (ackedTransitions) (Can be skipped, if the value is null)
		var ackedTransitions *BACnetEventTransitionBitsTagged = nil
		if m.AckedTransitions != nil {
			if pushErr := writeBuffer.PushContext("ackedTransitions"); pushErr != nil {
				return pushErr
			}
			ackedTransitions = m.AckedTransitions
			_ackedTransitionsErr := ackedTransitions.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("ackedTransitions"); popErr != nil {
				return popErr
			}
			if _ackedTransitionsErr != nil {
				return errors.Wrap(_ackedTransitionsErr, "Error serializing 'ackedTransitions' field")
			}
		}

		// Optional Field (notifyType) (Can be skipped, if the value is null)
		var notifyType *BACnetNotifyTypeTagged = nil
		if m.NotifyType != nil {
			if pushErr := writeBuffer.PushContext("notifyType"); pushErr != nil {
				return pushErr
			}
			notifyType = m.NotifyType
			_notifyTypeErr := notifyType.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("notifyType"); popErr != nil {
				return popErr
			}
			if _notifyTypeErr != nil {
				return errors.Wrap(_notifyTypeErr, "Error serializing 'notifyType' field")
			}
		}

		// Optional Field (eventDetectionEnable) (Can be skipped, if the value is null)
		var eventDetectionEnable *BACnetApplicationTagBoolean = nil
		if m.EventDetectionEnable != nil {
			if pushErr := writeBuffer.PushContext("eventDetectionEnable"); pushErr != nil {
				return pushErr
			}
			eventDetectionEnable = m.EventDetectionEnable
			_eventDetectionEnableErr := eventDetectionEnable.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("eventDetectionEnable"); popErr != nil {
				return popErr
			}
			if _eventDetectionEnableErr != nil {
				return errors.Wrap(_eventDetectionEnableErr, "Error serializing 'eventDetectionEnable' field")
			}
		}

		// Optional Field (eventAlgorithmInhibitRef) (Can be skipped, if the value is null)
		var eventAlgorithmInhibitRef *BACnetObjectPropertyReference = nil
		if m.EventAlgorithmInhibitRef != nil {
			if pushErr := writeBuffer.PushContext("eventAlgorithmInhibitRef"); pushErr != nil {
				return pushErr
			}
			eventAlgorithmInhibitRef = m.EventAlgorithmInhibitRef
			_eventAlgorithmInhibitRefErr := eventAlgorithmInhibitRef.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("eventAlgorithmInhibitRef"); popErr != nil {
				return popErr
			}
			if _eventAlgorithmInhibitRefErr != nil {
				return errors.Wrap(_eventAlgorithmInhibitRefErr, "Error serializing 'eventAlgorithmInhibitRef' field")
			}
		}

		// Optional Field (eventAlgorithmInhibit) (Can be skipped, if the value is null)
		var eventAlgorithmInhibit *BACnetApplicationTagBoolean = nil
		if m.EventAlgorithmInhibit != nil {
			if pushErr := writeBuffer.PushContext("eventAlgorithmInhibit"); pushErr != nil {
				return pushErr
			}
			eventAlgorithmInhibit = m.EventAlgorithmInhibit
			_eventAlgorithmInhibitErr := eventAlgorithmInhibit.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("eventAlgorithmInhibit"); popErr != nil {
				return popErr
			}
			if _eventAlgorithmInhibitErr != nil {
				return errors.Wrap(_eventAlgorithmInhibitErr, "Error serializing 'eventAlgorithmInhibit' field")
			}
		}

		// Optional Field (timeDelayNormal) (Can be skipped, if the value is null)
		var timeDelayNormal *BACnetApplicationTagUnsignedInteger = nil
		if m.TimeDelayNormal != nil {
			if pushErr := writeBuffer.PushContext("timeDelayNormal"); pushErr != nil {
				return pushErr
			}
			timeDelayNormal = m.TimeDelayNormal
			_timeDelayNormalErr := timeDelayNormal.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("timeDelayNormal"); popErr != nil {
				return popErr
			}
			if _timeDelayNormalErr != nil {
				return errors.Wrap(_timeDelayNormalErr, "Error serializing 'timeDelayNormal' field")
			}
		}

		// Optional Field (reliabilityEvaluationInhibit) (Can be skipped, if the value is null)
		var reliabilityEvaluationInhibit *BACnetApplicationTagBoolean = nil
		if m.ReliabilityEvaluationInhibit != nil {
			if pushErr := writeBuffer.PushContext("reliabilityEvaluationInhibit"); pushErr != nil {
				return pushErr
			}
			reliabilityEvaluationInhibit = m.ReliabilityEvaluationInhibit
			_reliabilityEvaluationInhibitErr := reliabilityEvaluationInhibit.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("reliabilityEvaluationInhibit"); popErr != nil {
				return popErr
			}
			if _reliabilityEvaluationInhibitErr != nil {
				return errors.Wrap(_reliabilityEvaluationInhibitErr, "Error serializing 'reliabilityEvaluationInhibit' field")
			}
		}

		// Optional Field (interfaceValue) (Can be skipped, if the value is null)
		var interfaceValue *BACnetOptionalREAL = nil
		if m.InterfaceValue != nil {
			if pushErr := writeBuffer.PushContext("interfaceValue"); pushErr != nil {
				return pushErr
			}
			interfaceValue = m.InterfaceValue
			_interfaceValueErr := interfaceValue.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("interfaceValue"); popErr != nil {
				return popErr
			}
			if _interfaceValueErr != nil {
				return errors.Wrap(_interfaceValueErr, "Error serializing 'interfaceValue' field")
			}
		}

		// Optional Field (faultHighLimit) (Can be skipped, if the value is null)
		var faultHighLimit *BACnetApplicationTagReal = nil
		if m.FaultHighLimit != nil {
			if pushErr := writeBuffer.PushContext("faultHighLimit"); pushErr != nil {
				return pushErr
			}
			faultHighLimit = m.FaultHighLimit
			_faultHighLimitErr := faultHighLimit.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("faultHighLimit"); popErr != nil {
				return popErr
			}
			if _faultHighLimitErr != nil {
				return errors.Wrap(_faultHighLimitErr, "Error serializing 'faultHighLimit' field")
			}
		}

		// Optional Field (faultLowLimit) (Can be skipped, if the value is null)
		var faultLowLimit *BACnetApplicationTagReal = nil
		if m.FaultLowLimit != nil {
			if pushErr := writeBuffer.PushContext("faultLowLimit"); pushErr != nil {
				return pushErr
			}
			faultLowLimit = m.FaultLowLimit
			_faultLowLimitErr := faultLowLimit.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("faultLowLimit"); popErr != nil {
				return popErr
			}
			if _faultLowLimitErr != nil {
				return errors.Wrap(_faultLowLimitErr, "Error serializing 'faultLowLimit' field")
			}
		}

		// Optional Field (profileLocation) (Can be skipped, if the value is null)
		var profileLocation *BACnetApplicationTagCharacterString = nil
		if m.ProfileLocation != nil {
			if pushErr := writeBuffer.PushContext("profileLocation"); pushErr != nil {
				return pushErr
			}
			profileLocation = m.ProfileLocation
			_profileLocationErr := profileLocation.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("profileLocation"); popErr != nil {
				return popErr
			}
			if _profileLocationErr != nil {
				return errors.Wrap(_profileLocationErr, "Error serializing 'profileLocation' field")
			}
		}

		// Optional Field (profileName) (Can be skipped, if the value is null)
		var profileName *BACnetApplicationTagCharacterString = nil
		if m.ProfileName != nil {
			if pushErr := writeBuffer.PushContext("profileName"); pushErr != nil {
				return pushErr
			}
			profileName = m.ProfileName
			_profileNameErr := profileName.Serialize(writeBuffer)
			if popErr := writeBuffer.PopContext("profileName"); popErr != nil {
				return popErr
			}
			if _profileNameErr != nil {
				return errors.Wrap(_profileNameErr, "Error serializing 'profileName' field")
			}
		}

		if popErr := writeBuffer.PopContext("BACnetConstructedDataAnalogInputAll"); popErr != nil {
			return popErr
		}
		return nil
	}
	return m.SerializeParent(writeBuffer, m, ser)
}

func (m *BACnetConstructedDataAnalogInputAll) String() string {
	if m == nil {
		return "<nil>"
	}
	buffer := utils.NewBoxedWriteBufferWithOptions(true, true)
	if err := m.Serialize(buffer); err != nil {
		return err.Error()
	}
	return buffer.GetBox().String()
}
